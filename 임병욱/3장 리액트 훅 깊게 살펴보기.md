## 🔥 정리하기
### 1. useState
리액트의 렌더링은 함수 컴포넌트에서 반환한 결과물인 return의 값을 비교해 실행된다.

클로저를 이용한 useState

```javascript
const MyReact - (function () {
  const global = {};
  let index = 0;

  function useState(initialState) {
    if (!global.states) {
      global.states = [];
    }
  }

  const currentState = global.states[index] || initialState

  global.states[index] = currentState

  const setState = (function () {
    let currentIndex = index
    return function (value) {
      global.states[currentIndex] = value
    }
  })()

  index = index + 1;

  return [currentState, setState]

})
```

> 게으른 초기화
- useState의 인수로 특정한 값을 넘기는 함수를 인수로 넣어줄 수 있다.
변수 대신 함수를 인수로 넘기는 것을 게으른 초기화라 한다.
- useState의 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용한다.
- 게으른 초기화 함수는 오로지 state가 처음 만들어질 때만 사용된다.
- 이후에 리렌더링이 발생된다면 함수의 실행은 무시된다.
```javascript
const [count, setCount] = useState(
  Number.parseInt(window.localStorage.getItem(cacheKey))
)

// 게으른 초기화
const [count, setCount] = useState(() => 
  Number.parseInt(window.localStorage.getItem(cacheKey))
)
```

### 2. useEffect
```javascript
useEffect(() => {
  // do something
}, [props, state])
```

클린업 함수의 목적
클린업 함수는 비록 새로운 값을 기반으로 렌더링 뒤에 실행되지만 이 변경된 값을 읽는 것이 아니라 함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행된다.

의존성 배열
1. 아무런 값도 넘겨주지 않으면 의존성을 비교할 필요 없이 렌더링할 때마다 실행이 필요하다고 판단해 렌더링이 발생할 때마다 실행된다.

```javascript
// 1
function Component() {
  console.log('렌더링됭')
}

// 2
function Component() {
  useEffect(() => {
    console.log('렌더링된')
  })
}
```

#### 1.useEffect 사용 시 주의할 점
##### eslint-disable-line react-hooks/exhaustive-deps 주석은 최대한 자제해라

```javascript
useEffect(() => {
  console.log(props)
}, [props])
```

##### useEffect의 첫 번째 인수에 함수명을 부여하라.
```javascript
useEffect(
  function logActiveUser() {
    logging(user.id)
  }, [user.id]
)
```

##### 거대한 useEffect를 만들지 마라.
큰 useEffect를 만들어야 한다면 적은 의존성 배열을 사용하는 여러 개의 useEffect로 분리하는 것이 좋다.

#####  불필요한 외부 함수를 만들지 마라

### 3. useMemo
useMemo는 비용이 큰 연산에 대한 결과를 저장해 두고, 이 저장된 **값**을 반환하는 훅
```javascript
const memoizedValue = useMemo(() => expensiveComputation(a, b), [a, b])

```

### 4. useCallback
- useMemo와 대조적으로 useCallback은 인수로 넘겨받은 콜백 자체를 기억한다.
쉽게 말해 useCallback은 특정 함수를 새로 만들지 않고 새로 재사용하는 것을 의미한다.

### 5. useRef
useRef는 useState와 동일하게 컴포넌트 내부에서 렝더링이 일어나도 변경 가능한 상태값을 저장한다는 공통점이 있다.
- useRef는 반환값인 객체 내부에 있는 current로 값에 접근 또는 변경할 수 있다.
- useRef는 그 값이 변하더라도 렌더링을 발생시키지 않는다.

> 그렇다면 컴포넌트 밖에서 변수 선언하면 안되나요?
1. 그렇게 되면 컴포넌트가 실행되어 렌더링 되기 전에 value의 값이 존재하는 문제점이 발생
2. 여러 컴포넌트들이 값은 값을 가리키는 문제점이 있다.

#### 6. useContext
- props drilling을 막고자 사용함
- useContext는 상태 관리를 위해 사용되는 것이 아니라 상태 주입을 위한 API다.
- useContext는 어떠한 상태를 기반으로 다른 상태를 만들어 낼 수도 없고 필요에 따라 이러한 상태 변화를 최적화 할 수도 없다.

7. useReducer
- useState의 심화 버전
- 반환값은 useState와 동일하게 길이가 2인 배열이다.
  - state: 현재 useReducer가 가지고 있는 값을 의미
  - dispatcher: state를 업데이트 하는 함수
    - setState와 달리 값이 아닌 action을 넘겨준다
  - useState의 인수와 달리 2개에서 3개의 인수를 필요로 한다.
    - reducer: userReducer의 기본 action을 정의하는 함수
    - initialState: 두 번째 인수로, useReducer의 초깃값을 의미
  