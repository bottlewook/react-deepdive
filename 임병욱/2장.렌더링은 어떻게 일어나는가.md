## 🔥 정리하기
### 1. 리액트의 렌더링이란
> 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 **props와 state의 값을 기반**으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다.

### 2. 리액트의 렌더링이 일어나는 이유
1. 최초 렌더링
2. 리렌더링
  1. 클래스 컴포넌트의 setState가 실행되는 경우
  2. 클래스 컴포넌트의 forceUpdate가 실행되는 경우
  3. 함수 컴포넌트의 setState가 변경되는 경우
  4. 함수 컴포넌트의 useReducer()의 두번째 배열 요소인 dispatch가 실행되는 경우
  5. 컴포넌트의 key props가 변경되는 경우
  6. props가 변경되는 경우
  7. 부모 컴포넌트가 렌더링될 경우

> key props를 시용하는 이유
리액트에서 key는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값
current 트리와 workInProgress 트리 사에어서 컴포넌트 변경점을 찾는데 사용한다.

### 3. 리액트의 렌더링 프로세스
렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다.
만약 업데이트가 필요하다면 클래스 컴포넌트의 경우 클래스 내부의 render() 함수를 실행하고 함수 컴포넌트는 FunctionComponent()를 호출한 뒤 결과물을 지정한다.

### 4. 렌더와 커밋
렌더 단계는 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 말한다.
렌더링 프로세스에서 컴포넌트를 실행해 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계다.

커밋 단계는 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정을 말한다. 이 단계가 끝나야 브라우저의 렌더링이 발생한다.

## 2. 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션
### 주장 1: 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자
memoization에서 발생하는 비용
1. 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업
2. 이전 결과물을 저장해두고 다시 꺼내오는 작업

### 주장 2: 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션 해버리자

### 정리
아직까지는 어떤 컴포넌트에 최적화를 염두해두고 memoization을 사용해야하는지 감이 잘 오지 않는다. 하지만 memo를 하게 되면 하지 않았을 때보다 더 나은 이점을 누릴 수 있다. 일반적으로 props에 대한 얕은 비교를 수행하는 것보다 리액트 컴포넌트의 결과물을 다시 계산하고 실제 DOM까지 비교하는 작업이 더욱 비싸고 무겁기 때문에 최적화를 고민해보는 것을 추천한다.
